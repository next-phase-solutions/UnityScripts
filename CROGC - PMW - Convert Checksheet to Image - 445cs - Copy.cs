// Skeleton generated by Hyland Unity Editor on 6/9/2014 11:36:29 AM
namespace ConvertEformChecksheetToImage
{
    using System;
    using System.Collections.Generic;
    using Hyland.Unity;
    using UnityFileConversions;

    /// <summary>
    /// Convert Eform Checksheet to Image
    /// </summary>
    public class ConvertEformChecksheetToImage : Hyland.Unity.IWorkflowScript
    {
        // Script name for diagnostics logging
        private const string ScriptName = "445 - CROGC - PMW - Convert Checksheet to Image";

        // Diagnostics logging level - set to Verbose for testing, Error for production
        private const Diagnostics.DiagnosticsLevel DiagLevel = Diagnostics.DiagnosticsLevel.Verbose;

        // Date/Time format for diagnostics logging
        private const string DateTimeFormat = "MM-dd-yyyy HH:mm:ss.fff";

        // Workflow property where error message will be stored
        private const string ErrorMessageProperty = "UnityError";

        // If true, errors will be added to document history
        private const bool WriteErrorsToHistory = true;

        private const string CRD_DOCUMENT_TYPE = "OGC - PMW - CR - Case Summary Sheet";
        private const long EFORM_FILE_TYPE = 24;
        private const long VFORM_FILE_TYPE = 27;
        private const long IMAGE_FILE_TYPE = 2;
        private const string TEMP_DIRECTORY = @"C:\Temp\Unity\";
        private const string CONVERTER_DIRECTORY = @"C:\Converter\FileConverter.exe";

        #region IWorkflowScript
        /// <summary>
        /// Implementation of <see cref="IWorkflowScript.OnWorkflowScriptExecute" />.
        /// <seealso cref="IWorkflowScript" />
        /// </summary>
        /// <param name="app"></param>
        /// <param name="args"></param>
        public void OnWorkflowScriptExecute(Hyland.Unity.Application app, Hyland.Unity.WorkflowEventArgs args)
        {

            try
            {
                // Script name for diagnostics logging
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Info, string.Format("{0} - Start Script - [{1}]", DateTime.Now.ToString(DateTimeFormat), ScriptName));

                // Get the active document
                Document objCurrentDocument = args.Document;
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Info, string.Format("Processing document: {0}", objCurrentDocument.ID.ToString()));

                // Get the default rendition and verify it is an e-form
                Rendition objFormRendition = objCurrentDocument.DefaultRenditionOfLatestRevision;
                if (objFormRendition.FileType.ID != EFORM_FILE_TYPE && objFormRendition.FileType.ID != VFORM_FILE_TYPE)
                {
                    throw new InvalidProgramException(string.Format("File format ({0}) is invalid!", objFormRendition.FileType.Name));
                }

                // Validate the document type
                DocumentType objCrdDocType = app.Core.DocumentTypes.Find(CRD_DOCUMENT_TYPE);
                if (objCrdDocType == null)
                {
                    throw new InvalidProgramException(string.Format("Document type \"{0}\" does not exist!", CRD_DOCUMENT_TYPE));
                }

                ConversionUtilities unityConverter = new ConversionUtilities(app, TEMP_DIRECTORY, CONVERTER_DIRECTORY);

                List<FileDefinition> files = unityConverter.Convert(args.Document, UnityFileConversions.ImxFileType.Image, UnityFileConversions.ImportType.Document, app.Core.DocumentTypes.Find(CRD_DOCUMENT_TYPE), true);

                unityConverter.CleanupFiles();

                args.ScriptResult = true;

            }
            catch (InvalidProgramException ex)
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, string.Format("Invalid Program Exception: {0}", ex.Message));
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, string.Format("Stack Trace: {0}", ex.StackTrace));
                args.ScriptResult = false;
            }
            catch (UnityAPIException ex)
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, string.Format("Unity API Exception: {0}", ex.Message));
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, string.Format("Stack Trace: {0}", ex.StackTrace));
                args.ScriptResult = false;
            }
            catch (Exception ex)
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, string.Format("General Exception: {0}", ex.Message));
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, string.Format("Stack Trace: {0}", ex.StackTrace));
                args.ScriptResult = false;
            }
            finally
            {
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Info, ScriptName);
            }
        }
        #endregion

        #region Helper Functions
        /// <summary>
        /// Initialize global settings
        /// </summary>
        /// <param name="app">Unity Application object</param>
        /// <param name="args">Workflow event arguments</param>
        private void IntializeScript(ref Application app, ref WorkflowEventArgs args)
        {
            // Set the specified diagnostics level
            app.Diagnostics.Level = DiagLevel;

            // Log script execution start
            app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Info,
                string.Format("{0} - Start Script - [{1}]", DateTime.Now.ToString(DateTimeFormat), ScriptName));

            // Capture active document as global
            _currentDocument = args.Document;
            //  _currentDocument = app.Core.GetDocumentByID(TestDocId);
            // If an error was stored in the property bag from a previous execution, clear it
            if (args.SessionPropertyBag.ContainsKey(ErrorMessageProperty)) args.SessionPropertyBag.Remove(ErrorMessageProperty);

            // Set ScriptResult = true for workflow rules (will become false if an error is caught)
            args.ScriptResult = true;
        }

        /// <summary>
        /// Handle exceptions and log to Diagnostics Console and document history
        /// </summary>
        /// <param name="ex">Exception</param>
        /// <param name="app">Unity Application object</param>
        /// <param name="args">Workflow event arguments</param>
        /// <param name="otherDocument">Document on which to update history if not active workflow document</param>
        private void HandleException(Exception ex, ref Application app, ref WorkflowEventArgs args, Document otherDocument = null)
        {
            var history = app.Core.LogManagement;
            bool isInner = false;

            // Cycle through all inner exceptions
            while (ex != null)
            {
                // Construct error text to store to workflow property
                string propertyError = string.Format("{0}{1}: {2}",
                    isInner ? "Inner " : "",
                    ex.GetType().Name,
                    ex.Message);

                // Construct error text to store to document history
                string historyError = propertyError.Replace(ex.GetType().Name, "Unity Script Error");

                // Construct error text to log to diagnostics console
                string diagnosticsError = string.Format("{0} - ***ERROR***{1}{2}{1}{1}Stack Trace:{1}{3}",
                    DateTime.Now.ToString(DateTimeFormat),
                    Environment.NewLine,
                    propertyError,
                    ex.StackTrace);

                // Add error message to document history (on current or specified document)
                var document = otherDocument ?? _currentDocument;
                if (document != null && WriteErrorsToHistory) history.CreateDocumentHistoryItem(document, historyError);

                // Write error message to Diagnostcs Consonle
                app.Diagnostics.WriteIf(Diagnostics.DiagnosticsLevel.Error, diagnosticsError);

                // Store the original (inner) exception message to error workflow property
                if (ex.InnerException == null) args.SessionPropertyBag.Set(ErrorMessageProperty, ex.Message);

                // Move on to next inner exception
                ex = ex.InnerException;
                isInner = true;
            }

            // Set ScriptResult = false for workflow rules
            args.ScriptResult = false;

        }
        private Keyword CreateKeywordHelper(KeywordType Keytype, string Value)
        {
            Keyword key = null;
            switch (Keytype.DataType)
            {
                case KeywordDataType.Currency:
                case KeywordDataType.Numeric20:
                    decimal decVal = decimal.Parse(Value);
                    key = Keytype.CreateKeyword(decVal);
                    break;
                case KeywordDataType.Date:
                case KeywordDataType.DateTime:
                    DateTime dateVal = DateTime.Parse(Value);
                    key = Keytype.CreateKeyword(dateVal);
                    break;
                case KeywordDataType.FloatingPoint:
                    double dblVal = double.Parse(Value);
                    key = Keytype.CreateKeyword(dblVal);
                    break;
                case KeywordDataType.Numeric9:
                    long lngVal = long.Parse(Value);
                    key = Keytype.CreateKeyword(lngVal);
                    break;
                default:
                    key = Keytype.CreateKeyword(Value);
                    break;
            }
            return key;
        }
        #endregion
    }
}